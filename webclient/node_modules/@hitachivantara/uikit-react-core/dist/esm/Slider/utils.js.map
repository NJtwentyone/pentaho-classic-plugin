{"version":3,"file":"utils.js","sources":["../../../src/Slider/utils.ts"],"sourcesContent":["import { CSSProperties } from \"react\";\n\nimport { theme } from \"@hitachivantara/uikit-styles\";\n\nimport validationStates from \"../Forms/FormElement/validationStates\";\nimport { HvFormStatus } from \"../Forms\";\n\nimport { HvKnobProperty, HvMarkProperty } from \"./types\";\nimport { sliderStyles as styles } from \"./Slider.styles\";\n\n/**\n * Transform the scaled values into knobs positions.\n *\n * @param {*} sliderValue - he value of the slider to be scaled\n * @param {*} minPointVlue - The value of the first point in the slider from left to right.\n * @param {*} stepVlue - The calculated separation between the values of the slider.\n */\nexport const knobsPositionToScaledValue = (\n  sliderValue: number,\n  minPointValue: number,\n  stepValue: number\n): number => minPointValue + stepValue * sliderValue;\n\n/**\n * Transform the scaled values into knobs positions.\n *\n * @param {*} scaledValue - The value of the slider to be scaled\n * @param {*} minPointValue - The value of the first point in\n * the slider from left to right.\n * @param {*} inverseStepValue - The inverse of calculated separation between\n * the value of the points that compose the slider.\n */\nexport const scaledValueToKnobsPositionValue = (\n  scaledValue: number | undefined,\n  minPointValue: number,\n  inverseStepValue: number\n): number =>\n  typeof scaledValue === \"number\"\n    ? Math.floor((scaledValue - minPointValue) * inverseStepValue)\n    : NaN;\n\n/**\n * Transform the received knobs values into knob positions\n *\n * @param {Object} values - The values of the slider.\n * @param {Number} inverseStepValue - The inverse of calculated separation between\n * the value of the points that compose the slider.\n * @param {Integer} minPointValue - The value of the first point in the slider from\n * left to right.\n * @returns {Array} - The position of the knobs.\n */\nexport const knobsValuesToKnobsPositions = (\n  values: (number | undefined)[],\n  inverseStepValue: number,\n  minPointValue: number\n): number[] => {\n  const knobsPositions: number[] = [];\n\n  values.forEach((value, index) => {\n    knobsPositions[index] = scaledValueToKnobsPositionValue(\n      value,\n      minPointValue,\n      inverseStepValue\n    );\n  });\n\n  return knobsPositions;\n};\n\n/**\n * Transform the received knobs positions into knob values\n *\n * @param {Object} knobPositions - The values of the slider.\n * @param {Number} stepValue - The calculated separation between\n * the value of the points that compose the slider.\n * @param {Integer} minPointValue - The value of the first point in the slider from\n * left to right.\n * @returns {Array} - The position of the knobs.\n */\nexport const knobsPositionsToKnobsValues = (\n  knobPositions: number[],\n  stepValue: number,\n  minPointValue: number\n): number[] => {\n  const knobsValues: number[] = [];\n\n  knobPositions.forEach((value, index) => {\n    knobsValues[index] = knobsPositionToScaledValue(\n      value,\n      minPointValue,\n      stepValue\n    );\n  });\n\n  return knobsValues;\n};\n\n/**\n * Calculates the separation between each value in the slider.\n *\n * @param {*} maxPointValue - The value of the last point in the slider from left to right.\n * @param {*} minPointValue - The value of the first point in the slider from left to right.\n * @param {*} divisionQuantity - How many subdivisions there are in the slider.\n */\nexport const calculateStepValue = (\n  maxPointValue: number,\n  minPointValue: number,\n  divisionQuantity: number\n): number => Math.abs(maxPointValue - minPointValue) / divisionQuantity;\n\n/**\n * Generates the inline styles used for the track of each knob, applying colors if necessary.\n *\n * @param {Object} markProperties - The object provided by the user with\n * the desired configuration for the marks.\n * @param {Integer} markstep - The separation between marks.\n * @param {Integer} divisionQuantity - How many subdivisions there are in the slider.\n * @param {Integer} minPointValue - The value of the first point in the slider from\n * left to right.\n * @param {Integer} stepValue - The calculated separation between the values of the slider.\n * @param {Integer} markDigits - How many decimals the mark will show.\n * @param {Function} formatMark - A function provided by the user that is going to\n * be executed to format the mark text.\n * @param {Object} styles - the default styles for the marks.\n * @returns {Object} - An object with the for the marks.\n * @memberof HvSlider\n */\nexport const createMark = (\n  markProperties: HvMarkProperty[],\n  markstep: number,\n  divisionQuantity: number,\n  minPointValue: number,\n  stepValue: number,\n  markDigits: number,\n  disabled: boolean,\n  formatMark: (label: React.ReactNode) => React.ReactNode = (mark) => mark\n): {\n  [key: number]: {\n    label: string;\n    style: CSSProperties;\n  };\n} => {\n  const marks: {\n    [key: number]: {\n      label: string;\n      style: CSSProperties;\n    };\n  } = {};\n\n  if (markProperties.length > 0) {\n    markProperties.forEach((markProperty) => {\n      if (typeof markProperty.position === \"number\") {\n        marks[markProperty.position] = disabled\n          ? {\n              label: `${markProperty.label}`,\n              style: {\n                ...styles.disabledMark,\n              },\n            }\n          : {\n              label: `${markProperty.label}`,\n              style: {\n                ...styles.mark,\n              },\n            };\n      }\n    });\n  } else {\n    const roundedMarkStep = Math.floor(markstep);\n\n    for (let index = 0; index <= divisionQuantity; index += roundedMarkStep) {\n      let labelValue: React.ReactNode = knobsPositionToScaledValue(\n        index,\n        minPointValue,\n        stepValue\n      ).toFixed(markDigits);\n\n      labelValue = formatMark?.(labelValue) || labelValue;\n\n      marks[index] = disabled\n        ? {\n            label: `${labelValue}`,\n            style: {\n              ...styles.disabledMark,\n            },\n          }\n        : {\n            label: `${labelValue}`,\n            style: {\n              ...styles.mark,\n            },\n          };\n    }\n  }\n\n  return marks;\n};\n\n/**\n * Generates the inline styles used for the track of each knob, applying colors if necessary.\n *\n * @param {Object} knobProperties - The object provided by the user with\n * the desired configuration for the knobs.\n * @param {Object} styles - the default styles for the tracks.\n * @returns {Object} - An object with the style for each track.\n * @memberof HvSlider\n */\nexport const createTrackStyles = (\n  knobProperties: HvKnobProperty[]\n): CSSProperties[] => {\n  const trackStyles: CSSProperties[] = [];\n\n  if (knobProperties.length > 0) {\n    knobProperties.forEach((knobProperty, index) => {\n      trackStyles[index] = { ...styles.track };\n      if (knobProperty.color) {\n        trackStyles[index].backgroundColor = knobProperty.trackColor;\n      }\n    });\n  }\n\n  return trackStyles;\n};\n\n/**\n * Generates the inline styles used for each knob, applying colors if specified.\n *\n * @param {Object} knobProperties - The object provided by the user with\n * the desired configuration for the knobs.\n * @param {Object} styles - the default styles for the knobs.\n * @returns {Object} - An object with both the inner and outer styles for the knob.\n * @memberof HvSlider\n */\nexport const createKnobStyles = (\n  knobProperties: HvKnobProperty[]\n): {\n  knobInner: CSSProperties[];\n  knobOuterStyle: CSSProperties[];\n} => {\n  const knobInner: CSSProperties[] = [];\n  const knobOuterStyle: CSSProperties[] = [];\n\n  const lastItem = knobProperties.length - 1;\n  if (knobProperties.length > 0) {\n    knobProperties.forEach((knobProperty, index) => {\n      knobInner[index] = { ...styles.knobInner };\n      knobOuterStyle[index] = { ...styles.knobOuter };\n\n      if (knobProperty.color) {\n        knobInner[index].backgroundColor = knobProperty.color;\n        knobOuterStyle[index].backgroundColor = \"transparent\";\n      }\n\n      if (knobProperty.hidden) {\n        knobInner[index] = styles.knobHidden;\n        if (index === lastItem) {\n          knobInner[index] = { ...styles.knobHiddenLast };\n          knobInner[index].backgroundColor = knobProperty.color;\n          knobOuterStyle[index] = { ...styles.knobHidden };\n          knobOuterStyle[index].backgroundColor = knobProperty.color;\n        }\n      }\n    });\n  }\n\n  return {\n    knobInner,\n    knobOuterStyle,\n  };\n};\n\n/**\n * Analyzes both the values and the default values to determine whether the slider is working in single mode.\n *\n * @param {Array} values - the values where the knobs are positioned when controlled.\n * @param {Array} defaultValues - the values where the knobs start when uncontrolled.\n * @returns {Boolean} - if true the slider should work as single slider\n */\nexport const isSingleSlider = (\n  values: number[],\n  defaultValues: (number | undefined)[]\n): boolean => {\n  if (!(values?.length > 1)) {\n    return defaultValues.length === 1;\n  }\n  return values.length === 1;\n};\n\n/**\n * Generates the default knob styles for each knob\n *\n * @param {Object} knobProperties - The object provided by the user with\n * the desired configuration for the knobs.\n * @param {Integer} numberOfKnobs - the default styles for the knobs.\n * @param {Object} theme - The theme to extract the colors.\n *\n * @returns {Object} - An object with both the inner and outer styles for the knob.\n * @memberof HvSlider\n */\nexport const generateDefaultKnobProperties = (\n  numberOfKnobs: number = 1,\n  disabled: boolean = false,\n  knobPropertiesProp?: HvKnobProperty[]\n): HvKnobProperty[] => {\n  let knobProperties = knobPropertiesProp || [];\n\n  const defaultKnobStyles = {\n    color: theme.colors.secondary,\n    hoverColor: theme.colors.secondary,\n    trackColor: theme.colors.secondary,\n    dragColor: theme.colors.secondary,\n    knobRingColor: theme.colors.atmo1,\n  };\n\n  const disabledKnobStyles = {\n    color: theme.colors.secondary_60,\n    hoverColor: theme.colors.secondary_60,\n    trackColor: theme.colors.secondary_60,\n    dragColor: theme.colors.secondary_60,\n    knobRingColor: theme.colors.secondary_60,\n  };\n\n  if (knobProperties.length > 0) {\n    knobProperties = knobProperties.slice(0, numberOfKnobs);\n    knobProperties = knobProperties.map((knobProperty) => {\n      if (!disabled) {\n        return {\n          ...disabledKnobStyles,\n          ...knobProperty,\n        };\n      }\n      return {\n        ...defaultKnobStyles,\n        ...knobProperty,\n      };\n    });\n  } else {\n    for (let i = 0; i < numberOfKnobs; i += 1) {\n      if (!disabled) knobProperties.push(defaultKnobStyles);\n      if (disabled) knobProperties.push(disabledKnobStyles);\n    }\n  }\n\n  return knobProperties;\n};\n\nconst pushSlider = (\n  index: number,\n  inputIndex: number,\n  inputValue: number\n): number => {\n  const difference = index - inputIndex;\n\n  return inputValue + difference;\n};\n\nexport const ensureValuesConsistency = (\n  knobPositions: number[],\n  inputIndex: number\n): number[] => {\n  const newKnobsPosition: number[] = [...knobPositions];\n\n  newKnobsPosition.forEach((value, index) => {\n    if (Number.isNaN(value) || value == null) {\n      newKnobsPosition[index] = pushSlider(\n        index,\n        inputIndex,\n        newKnobsPosition[inputIndex]\n      );\n    } else if (index < inputIndex && value > newKnobsPosition[inputIndex]) {\n      newKnobsPosition[index] = pushSlider(\n        index,\n        inputIndex,\n        newKnobsPosition[inputIndex]\n      );\n    } else if (index > inputIndex && value < newKnobsPosition[inputIndex]) {\n      newKnobsPosition[index] = pushSlider(\n        index,\n        inputIndex,\n        newKnobsPosition[inputIndex]\n      );\n    }\n  });\n\n  return newKnobsPosition;\n};\n\nexport const convertStatusToArray = (\n  length: number,\n  status?: HvFormStatus | HvFormStatus[]\n): {\n  arrayStatus?: HvFormStatus[];\n  arrayDefaultStatus: (keyof typeof validationStates)[];\n} => {\n  const result: {\n    arrayStatus?: HvFormStatus[];\n    arrayDefaultStatus: (keyof typeof validationStates)[];\n  } = {\n    arrayDefaultStatus: Array.from({ length }, () => validationStates.standBy),\n  };\n\n  if (status == null) {\n    return result;\n  }\n  if (!Array.isArray(status)) {\n    result.arrayStatus = Array.from({ length }, () => status);\n    return result;\n  }\n  result.arrayStatus = status;\n\n  return result;\n};\n\nexport const statusArrayToFormStatus = (\n  arrayStatus: HvFormStatus[]\n): keyof typeof validationStates => {\n  const invalid = arrayStatus.some(\n    (status) => status === validationStates.invalid\n  );\n\n  if (invalid) return validationStates.invalid;\n\n  const valid = arrayStatus.some((status) => status === validationStates.valid);\n\n  if (valid) return validationStates.valid;\n\n  return validationStates.standBy;\n};\n\nexport const knobsValuesToString = (\n  knobsValues: number[],\n  markDigits: number\n): string[] =>\n  knobsValues.map((knobValue) =>\n    Number.isNaN(knobValue) ? \"\" : knobValue.toFixed(markDigits)\n  );\n\nexport const stringValuesToKnobs = (inputsValues: string[]): number[] =>\n  inputsValues.map((inputValue) => parseFloat(inputValue));\n"],"names":["styles","validationStates"],"mappings":"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"}