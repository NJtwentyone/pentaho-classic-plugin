const spacingUtil = (value, vars) => {
  switch (typeof value) {
    case "number":
      return `calc(${vars.space.base} * ${value}px)`;
    case "string":
      return vars.space[value] || value;
    default:
      return value;
  }
};
const spacingUtilOld = (value, vars) => {
  switch (typeof value) {
    case "number":
      return `${value}px`;
    case "string":
      return vars.space[value] || value;
    default:
      return "0px";
  }
};
const toCSSVars = (obj, prefix = "--uikit") => {
  const vars = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "object") {
      const nestedVars = toCSSVars(value, `${prefix}-${key}`);
      for (const [nestedKey, nestedValue] of Object.entries(nestedVars)) {
        vars[nestedKey] = nestedValue;
      }
    } else {
      vars[`${prefix}-${key}`] = value;
    }
  }
  return vars;
};
const hasMultipleArgs = (args) => {
  return args.length > 1;
};
const mapCSSVars = (obj, prefix = "--uikit") => {
  const vars = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "object") {
      vars[key] = mapCSSVars(value, `${prefix}-${key}`);
    } else {
      vars[key] = `var(${prefix}-${key})`;
    }
  }
  return vars;
};
const mergeTheme = (...objects) => {
  const isObject = (obj) => obj && typeof obj === "object";
  return objects.reduce((prev, obj) => {
    Object.keys(obj).forEach((key) => {
      const pVal = prev[key];
      const oVal = obj[key];
      if (isObject(pVal) && isObject(oVal)) {
        prev[key] = pVal ? oVal : mergeTheme(pVal, oVal);
      } else {
        prev[key] = oVal;
      }
    });
    return prev;
  }, {});
};
const parseTheme = (themes, theme = "", colorMode = "") => {
  const names = themes.map((t) => t.name);
  const selectedTheme = names.includes(theme) ? theme : names[0];
  const themeStructure = themes.find((t) => t.name === selectedTheme) || themes[0];
  const colorModes = Object.keys(themeStructure.colors.modes);
  const selectedMode = colorModes.includes(colorMode) ? colorMode : colorModes[0];
  const colorScheme = themeStructure.colors.modes[selectedMode].type;
  return {
    theme: themeStructure,
    selectedTheme,
    selectedMode,
    colorModes,
    colorScheme
  };
};
const getThemesList = (themes) => {
  const list = {};
  Object.keys(themes).forEach((themeName) => {
    const theme = themes[themeName];
    const colorModes = Object.keys(theme.colors.modes);
    list[themeName] = {
      colorModes: {}
    };
    colorModes.forEach((colorMode) => {
      list[themeName].colorModes[colorMode] = toCSSVars({
        ...theme,
        colors: {
          ...theme.colors.modes[colorMode]
        }
      });
    });
  });
  return list;
};
const colorToRgb = (color) => {
  const rgbaRegex = /^rgba\(\s*(-?\d+|-?\d*\.\d+(?=%))(%?)\s*,\s*(-?\d+|-?\d*\.\d+(?=%))(\2)\s*,\s*(-?\d+|-?\d*\.\d+(?=%))(\2)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)$/g;
  const rgbRegex = /^rgb\(\s*(-?\d+|-?\d*\.\d+(?=%))(%?)\s*,\s*(-?\d+|-?\d*\.\d+(?=%))(\2)\s*,\s*(-?\d+|-?\d*\.\d+(?=%))(\2)\s*\)$/g;
  const match = color.trim().match(rgbaRegex) || color.trim().match(rgbRegex);
  if (match) {
    const channels = match[0].replace(/rgba|rgb|\(|\)/g, "").split(",");
    if (channels.length > 3) {
      channels.pop();
    }
    return channels.join(" ");
  }
  const hexRegex = /^(?:#)(?:[a-f0-9]{3}|[a-f0-9]{4}|[a-f0-9]{6}|[a-f0-9]{8})$/gi;
  const hexMatch = color.trim().match(hexRegex);
  if (!hexMatch)
    return;
  let value = hexMatch[0].replace("#", "");
  if (value.length === 3 || value.length === 4) {
    value = Array.from(value).map((d) => `${d}${d}`).join("");
  }
  return [
    parseInt(value.substring(0, 2), 16),
    parseInt(value.substring(2, 4), 16),
    parseInt(value.substring(4, 6), 16)
  ].join(" ");
};
const getThemesVars = (themes) => {
  const vars = {};
  themes.forEach((theme) => {
    const colorModes = Object.keys(theme.colors.modes);
    colorModes.forEach((colorMode) => {
      const styleName = `[data-theme="${theme.name}"][data-color-mode="${colorMode}"]`;
      const { components, name, colors, ...rest } = theme;
      const rgbColors = Object.entries(colors.modes[colorMode]).reduce(
        (acc, [key, value]) => {
          const rgb = colorToRgb(value);
          if (rgb)
            acc[key] = rgb;
          return acc;
        },
        {}
      );
      vars[styleName] = toCSSVars({
        ...rest,
        colors: {
          ...colors.modes[colorMode]
        },
        // Colors as R G B channels
        rgb: {
          ...rgbColors
        }
      });
    });
  });
  return vars;
};
export {
  getThemesList,
  getThemesVars,
  hasMultipleArgs,
  mapCSSVars,
  mergeTheme,
  parseTheme,
  spacingUtil,
  spacingUtilOld
};
