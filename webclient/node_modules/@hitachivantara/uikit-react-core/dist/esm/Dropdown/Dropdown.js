import { jsxs, jsx } from "@emotion/react/jsx-runtime";
import { forwardRef, useState, useRef, useEffect } from "react";
import { useForkRef } from "@mui/material/utils";
import { useDefaultProps } from "../hooks/useDefaultProps.js";
import { setId } from "../utils/setId.js";
import { useLabels } from "../hooks/useLabels.js";
import { useUniqueId } from "../hooks/useUniqueId.js";
import { useControlled } from "../hooks/useControlled.js";
import { getSelectionLabel, getSelected } from "./utils.js";
import { useClasses } from "./Dropdown.styles.js";
import { staticClasses } from "./Dropdown.styles.js";
import { HvDropdownList } from "./List/List.js";
import { isInvalid } from "../Forms/FormElement/validationStates.js";
import { HvFormElement } from "../Forms/FormElement/FormElement.js";
import { HvLabel } from "../Forms/Label/Label.js";
import { HvInfoMessage } from "../Forms/InfoMessage/InfoMessage.js";
import { HvBaseDropdown } from "../BaseDropdown/BaseDropdown.js";
import { HvWarningText } from "../Forms/WarningText/WarningText.js";
import { HvTypography } from "../Typography/Typography.js";
const DEFAULT_LABELS = {
  /** Label for overwrite the default header behavior. */
  select: void 0,
  /** Label used for the All checkbox action. */
  selectAll: "All",
  /** Cancel button label. */
  cancelLabel: "Cancel",
  /** Apply button label. */
  applyLabel: "Apply",
  /** The label used in the middle of the multiSelection count. */
  searchPlaceholder: "Search",
  /** The label used in search. */
  multiSelectionConjunction: "/"
};
const HvDropdown = forwardRef(
  (props, ref) => {
    const {
      classes: classesProp,
      className,
      id,
      name,
      required = false,
      disabled = false,
      readOnly = false,
      label,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      description,
      "aria-describedby": ariaDescribedBy,
      placeholder = "Select...",
      onChange,
      status,
      statusMessage,
      "aria-errormessage": ariaErrorMessage,
      onCancel,
      onToggle,
      onClickOutside,
      onFocus,
      onBlur,
      values,
      multiSelect = false,
      showSearch = false,
      expanded,
      defaultExpanded = false,
      notifyChangesOnFirstRender = false,
      labels: labelsProp,
      hasTooltips = false,
      disablePortal = false,
      singleSelectionToggle = true,
      placement,
      variableWidth = false,
      popperProps = {},
      height,
      maxHeight,
      virtualized = false,
      baseDropdownProps = {},
      listProps = {},
      ...others
    } = useDefaultProps("HvDropdown", props);
    const { classes, cx } = useClasses(classesProp);
    const labels = useLabels(DEFAULT_LABELS, labelsProp);
    const elementId = useUniqueId(id, "hvdropdown");
    const [validationState, setValidationState] = useControlled(
      status,
      "standBy"
    );
    const [validationMessage] = useControlled(statusMessage, "Required");
    const [isOpen, setIsOpen] = useControlled(
      expanded,
      Boolean(defaultExpanded)
    );
    const [selectionLabel, setSelectionLabel] = useState(
      getSelectionLabel(labels, placeholder, multiSelect, values)
    );
    const [internalValues, setInternalValues] = useState(values);
    const internalValuesRef = useRef(values);
    useEffect(() => {
      setInternalValues(values);
      internalValuesRef.current = values;
    }, [values]);
    useEffect(() => {
      setSelectionLabel(
        getSelectionLabel(labels, placeholder, multiSelect, values)
      );
    }, [labels, multiSelect, placeholder, values]);
    const dropdownHeaderRef = useRef();
    const {
      ref: refProp,
      dropdownHeaderRef: dropdownHeaderRefProp,
      ...otherBaseDropdownProps
    } = baseDropdownProps;
    const headerForkedRef = useForkRef(
      dropdownHeaderRefProp,
      dropdownHeaderRef
    );
    const dropdownForkedRef = useForkRef(ref, refProp);
    const handleToggle = (event, open) => {
      onToggle?.(event, open);
      setIsOpen(open);
      if (!open) {
        setValidationState(() => {
          if (required) {
            const hasSelection = getSelected(internalValuesRef.current).length > 0;
            if (!hasSelection) {
              return "invalid";
            }
          }
          return "valid";
        });
      }
    };
    const handleSelection = (listValues, commitChanges, toggle, notifyChanges = true) => {
      const selected = getSelected(listValues);
      if (commitChanges) {
        setInternalValues(listValues);
        internalValuesRef.current = listValues;
        setSelectionLabel(
          getSelectionLabel(labels, placeholder, multiSelect, listValues)
        );
        setValidationState(() => {
          if (required && selected.length === 0) {
            return "invalid";
          }
          return "valid";
        });
      }
      if (notifyChanges)
        onChange?.(multiSelect ? selected : selected[0]);
      if (toggle) {
        handleToggle(void 0, false);
        dropdownHeaderRef.current?.focus({ preventScroll: true });
      }
    };
    const handleCancel = (evt) => {
      onCancel?.(evt);
      handleToggle(evt, false);
      dropdownHeaderRef.current?.focus({ preventScroll: true });
    };
    const handleClickOutside = (evt) => {
      onClickOutside?.(evt);
      onCancel?.(evt);
    };
    const setFocusToContent = (containerRef) => {
      const inputs = containerRef?.getElementsByTagName("input");
      if (inputs && inputs.length > 0) {
        inputs[0].focus();
        return;
      }
      const listItems = containerRef != null ? [...containerRef.getElementsByTagName("li")] : [];
      listItems.every((listItem) => {
        if (listItem.tabIndex >= 0) {
          listItem.focus();
          return false;
        }
        return true;
      });
    };
    const buildHeaderLabel = () => {
      const hasSelection = getSelected(internalValues).length > 0;
      return labels?.select || !multiSelect ? /* @__PURE__ */ jsx(
        HvTypography,
        {
          component: "div",
          variant: "body",
          className: cx(classes.placeholder, {
            [classes.selectionDisabled]: disabled,
            [classes.placeholderClosed]: !(isOpen || hasSelection)
          }),
          children: selectionLabel.selected
        }
      ) : /* @__PURE__ */ jsxs(
        HvTypography,
        {
          component: "div",
          className: cx(classes.placeholder, {
            [classes.selectionDisabled]: disabled
          }),
          variant: "body",
          children: [
            /* @__PURE__ */ jsx("b", { children: selectionLabel.selected }),
            ` ${labels?.multiSelectionConjunction} ${selectionLabel.total}`
          ]
        }
      );
    };
    const hasLabel = label != null;
    const hasDescription = description != null;
    const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
    const isStateInvalid = isInvalid(validationState);
    let errorMessageId;
    if (isStateInvalid) {
      errorMessageId = canShowError ? setId(elementId, "error") : ariaErrorMessage;
    }
    return /* @__PURE__ */ jsxs(
      HvFormElement,
      {
        id,
        name,
        status: validationState,
        disabled,
        readOnly,
        required,
        className: cx(
          classes.root,
          {
            [classes.disabled]: disabled
          },
          className
        ),
        ...others,
        children: [
          (hasLabel || hasDescription) && /* @__PURE__ */ jsxs("div", { className: classes.labelContainer, children: [
            hasLabel && /* @__PURE__ */ jsx(
              HvLabel,
              {
                id: setId(elementId, "label"),
                label,
                className: classes.label
              }
            ),
            hasDescription && /* @__PURE__ */ jsx(
              HvInfoMessage,
              {
                id: setId(elementId, "description"),
                className: classes.description,
                children: description
              }
            )
          ] }),
          /* @__PURE__ */ jsx(
            HvBaseDropdown,
            {
              ref: dropdownForkedRef,
              id: setId(id, "dropdown"),
              classes: {
                root: cx(classes.dropdown, {
                  [classes.readOnly]: readOnly
                }),
                arrow: classes.arrow,
                header: cx(classes.dropdownHeader, {
                  [classes.dropdownHeaderInvalid]: isStateInvalid
                }),
                headerOpen: classes.dropdownHeaderOpen
              },
              expanded: isOpen,
              disabled,
              readOnly,
              required,
              disablePortal,
              placement,
              popperProps,
              placeholder: buildHeaderLabel(),
              onToggle: handleToggle,
              onClickOutside: handleClickOutside,
              onContainerCreation: setFocusToContent,
              role: "combobox",
              variableWidth,
              "aria-label": ariaLabel,
              "aria-labelledby": [label && setId(elementId, "label"), ariaLabelledBy].join(" ").trim() || void 0,
              "aria-invalid": isStateInvalid ? true : void 0,
              "aria-errormessage": errorMessageId,
              "aria-describedby": [description && setId(elementId, "description"), ariaDescribedBy].join(" ").trim() || void 0,
              onFocus,
              onBlur,
              dropdownHeaderRef: headerForkedRef,
              ...otherBaseDropdownProps,
              children: /* @__PURE__ */ jsx(
                HvDropdownList,
                {
                  id: setId(elementId, "values"),
                  classes: {
                    rootList: classes.rootList,
                    dropdownListContainer: classes.dropdownListContainer
                  },
                  values: internalValues,
                  multiSelect,
                  showSearch,
                  onChange: handleSelection,
                  onCancel: handleCancel,
                  labels,
                  notifyChangesOnFirstRender,
                  hasTooltips,
                  singleSelectionToggle,
                  "aria-label": ariaLabel,
                  "aria-labelledby": hasLabel ? setId(elementId, "label") : void 0,
                  height,
                  maxHeight,
                  virtualized,
                  ...listProps
                }
              )
            }
          ),
          canShowError && /* @__PURE__ */ jsx(
            HvWarningText,
            {
              id: setId(elementId, "error"),
              disableBorder: true,
              className: classes.error,
              children: validationMessage
            }
          )
        ]
      }
    );
  }
);
export {
  HvDropdown,
  staticClasses as dropdownClasses
};
