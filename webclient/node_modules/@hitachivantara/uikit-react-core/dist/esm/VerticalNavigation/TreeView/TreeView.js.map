{"version":3,"file":"TreeView.js","sources":["../../../../src/VerticalNavigation/TreeView/TreeView.tsx"],"sourcesContent":["import { forwardRef, useCallback, useMemo, useRef, useState } from \"react\";\n\nimport { useControlled } from \"../../hooks/useControlled\";\nimport { useUniqueId } from \"../../hooks/useUniqueId\";\nimport { useForkRef } from \"../../hooks/useForkRef\";\n\nimport { ExtractNames } from \"../../utils/classes\";\n\nimport {\n  NavigationMode,\n  TreeViewControlContext,\n  TreeViewStateContext,\n} from \"./TreeViewContext\";\nimport { DescendantProvider } from \"./descendants\";\nimport { staticClasses, useClasses } from \"./TreeView.styles\";\n\nexport { staticClasses as treeViewClasses };\n\nexport type HvVerticalNavigationTreeViewClasses = ExtractNames<\n  typeof useClasses\n>;\n\nexport interface HvVerticalNavigationTreeViewProps {\n  /**\n   * Id to be applied to the root node.\n   */\n  id?: string;\n  /**\n   * Class names to be applied.\n   */\n  className?: string;\n  /**\n   * A Jss Object used to override or extend the styles applied to the component.\n   */\n  classes?: HvVerticalNavigationTreeViewClasses;\n  /**\n   * Modus operandi (role) of the widget instance.\n   */\n  mode?: NavigationMode;\n  /**\n   * Enables selection.\n   * @default false\n   */\n  selectable?: boolean;\n  /**\n   * Enables the simultaneous selection of multiple items.\n   * @default false\n   */\n  multiSelect?: boolean;\n  /**\n   * The selected nodes' ids.\n   *\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   */\n  selected?: string[] | string;\n  /**\n   * When uncontrolled, defines the initial selected nodes' ids.\n   *\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   * @default []\n   */\n  defaultSelected?: string[] | string;\n  /**\n   * Can non-leaf nodes be collapsed / expanded.\n   */\n  collapsible?: boolean;\n  /**\n   * Callback fired when a tree item is selected.\n   *\n   * @param {object} event The event source of the callback.\n   * @param {string} nodeId The id of the selected node.\n   */\n  onChange?: any;\n  /**\n   * Expanded nodes' ids.\n   */\n  expanded?: string[];\n  /**\n   * When uncontrolled, defines the initial expanded nodes' ids.\n   * @default []\n   */\n  defaultExpanded?: string[];\n  /**\n   * Callback fired when tree items are expanded/collapsed.\n   *\n   * @param {object} event The event source of the callback.\n   * @param {array} nodeIds The ids of the expanded nodes (old and new).\n   */\n  onToggle?: (event, nodeIds) => void;\n  /**\n   * If `true`, will allow focus on disabled items.\n   * @default false\n   */\n  disabledItemsFocusable?: boolean;\n  /**\n   * @ignore\n   */\n  onFocus?: (event: React.FocusEvent<any>) => void;\n  /**\n   * @ignore\n   */\n  onBlur?: (event: any) => void;\n  /**\n   * @ignore\n   */\n  onKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * The content of the component.\n   */\n  children?: React.ReactNode;\n}\n\nfunction isPrintableCharacter(string) {\n  return string && string.length === 1 && string.match(/\\S/);\n}\n\nfunction findNextFirstChar(firstChars, startIndex, char) {\n  for (let i = startIndex; i < firstChars.length; i += 1) {\n    if (char === firstChars[i]) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction noopSelection() {\n  return false;\n}\n\nexport const HvVerticalNavigationTreeView = forwardRef(\n  (props: HvVerticalNavigationTreeViewProps, ref) => {\n    const {\n      id: idProp,\n      className,\n      classes: classesProp,\n\n      mode = \"treeview\",\n\n      collapsible = false,\n      expanded: expandedProp,\n      defaultExpanded = [],\n      onToggle,\n\n      selectable = false,\n      multiSelect: multiSelectProp = false,\n      selected: selectedProp,\n      defaultSelected = [],\n      onChange,\n\n      disabledItemsFocusable = false,\n\n      onFocus,\n      onBlur,\n      onKeyDown,\n\n      children,\n\n      ...others\n    } = props;\n\n    const { classes, cx } = useClasses(classesProp);\n\n    const treeviewMode = mode === \"treeview\";\n    const multiSelect = selectable && multiSelectProp;\n\n    const treeId = useUniqueId(idProp, \"hvtreeview\");\n    const treeRef = useRef<HTMLDivElement>(null);\n    const handleRef = useForkRef(treeRef, ref);\n\n    const [expanded, setExpandedState] = useControlled(\n      expandedProp,\n      defaultExpanded\n    );\n\n    const [selected, setSelectedState] = useControlled(\n      selectedProp,\n      defaultSelected\n    );\n\n    const [focusedNodeId, setFocusedNodeId] = useState<string | null>(null);\n\n    const nodeMap = useRef({});\n\n    const firstCharMap = useRef({});\n\n    /*\n     * Status Helpers\n     */\n    const isExpanded = useCallback(\n      (id) =>\n        !collapsible ||\n        (Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false),\n      [collapsible, expanded]\n    );\n\n    const isExpandable = useCallback(\n      (id) =>\n        collapsible && nodeMap.current[id] && nodeMap.current[id].expandable,\n      [collapsible]\n    );\n\n    const isSelected = useCallback(\n      (id) =>\n        selectable &&\n        (Array.isArray(selected)\n          ? selected.indexOf(id) !== -1\n          : selected === id),\n      [selectable, selected]\n    );\n\n    const isSelectable = useCallback(\n      (id) =>\n        selectable && nodeMap.current[id] && nodeMap.current[id].selectable,\n      [selectable]\n    );\n\n    const isDisabled = useCallback((id) => {\n      let node = nodeMap.current[id];\n\n      // This can be called before the node has been added to the node map.\n      if (!node) {\n        return false;\n      }\n\n      if (node.disabled) {\n        return true;\n      }\n\n      while (node.parentId != null) {\n        node = nodeMap.current[node.parentId];\n        if (node.disabled) {\n          return true;\n        }\n      }\n\n      return false;\n    }, []);\n\n    const isFocused = useCallback(\n      (id) => focusedNodeId === id,\n      [focusedNodeId]\n    );\n\n    const isChildSelected = useCallback(\n      // the second part of the condition is to ensure that the id we're\n      // looking at is actually of a child (ie, there's at least one \"-\")\n      (id) => selected.startsWith(id) && selected.includes(\"-\"),\n      [selected]\n    );\n\n    /*\n     * Child Helpers\n     */\n    const getChildrenIds = (id: string | null) =>\n      Object.keys(nodeMap.current)\n        .map((key) => {\n          return nodeMap.current[key];\n        })\n        .filter((node) => node.parentId === id)\n        .sort((a, b) => a.index - b.index)\n        .map((child) => child.id);\n\n    const getNavigableChildrenIds = useCallback(\n      (id: string | null) => {\n        let childrenIds = getChildrenIds(id);\n\n        if (!disabledItemsFocusable) {\n          childrenIds = childrenIds.filter((node) => !isDisabled(node));\n        }\n        return childrenIds;\n      },\n      [disabledItemsFocusable, isDisabled]\n    );\n\n    /*\n     * Node Helpers\n     */\n    const getNextNode = useCallback(\n      (id: string) => {\n        // If expanded get first child\n        if (isExpanded(id) && getNavigableChildrenIds(id).length > 0) {\n          return getNavigableChildrenIds(id)[0];\n        }\n\n        let node = nodeMap.current[id];\n        while (node != null) {\n          // Try to get next sibling\n          const siblings = getNavigableChildrenIds(node.parentId);\n          const nextSibling = siblings[siblings.indexOf(node.id) + 1];\n\n          if (nextSibling) {\n            return nextSibling;\n          }\n\n          // If the sibling does not exist, go up a level to the parent and try again.\n          node = nodeMap.current[node.parentId];\n        }\n\n        return null;\n      },\n      [getNavigableChildrenIds, isExpanded]\n    );\n\n    const getPreviousNode = (id: string) => {\n      const node = nodeMap.current[id];\n      const siblings = getNavigableChildrenIds(node.parentId);\n      const nodeIndex = siblings.indexOf(id);\n\n      if (nodeIndex === 0) {\n        return node.parentId;\n      }\n\n      let currentNode = siblings[nodeIndex - 1];\n      while (\n        isExpanded(currentNode) &&\n        getNavigableChildrenIds(currentNode).length > 0\n      ) {\n        currentNode = getNavigableChildrenIds(currentNode).pop();\n      }\n\n      return currentNode;\n    };\n\n    const getLastNode = () => {\n      let lastNode = getNavigableChildrenIds(null).pop();\n\n      while (isExpanded(lastNode)) {\n        lastNode = getNavigableChildrenIds(lastNode).pop();\n      }\n      return lastNode;\n    };\n    const getFirstNode = () => getNavigableChildrenIds(null)[0];\n    const getParent = (id) => nodeMap.current[id].parentId;\n\n    /**\n     * This is used to determine the start and end of a selection range so\n     * we can get the nodes between the two border nodes.\n     *\n     * It finds the nodes' common ancestor using\n     * a naive implementation of a lowest common ancestor algorithm\n     * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).\n     * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB\n     * so we can compare their indexes to work out which node comes first in a depth first search.\n     * (https://en.wikipedia.org/wiki/Depth-first_search)\n     *\n     * Another way to put it is which node is shallower in a trÃ©maux tree\n     * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree\n     */\n    const findOrderInTremauxTree = useCallback(\n      (nodeAId: string, nodeBId: string) => {\n        if (nodeAId === nodeBId) {\n          return [nodeAId, nodeBId];\n        }\n\n        const nodeA = nodeMap.current[nodeAId];\n        const nodeB = nodeMap.current[nodeBId];\n\n        if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {\n          return nodeB.parentId === nodeA.id\n            ? [nodeA.id, nodeB.id]\n            : [nodeB.id, nodeA.id];\n        }\n\n        const aFamily = [nodeA.id];\n        const bFamily = [nodeB.id];\n\n        let aAncestor = nodeA.parentId;\n        let bAncestor = nodeB.parentId;\n\n        let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n        let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n\n        let continueA = true;\n        let continueB = true;\n\n        while (!bAncestorIsCommon && !aAncestorIsCommon) {\n          if (continueA) {\n            aFamily.push(aAncestor);\n            aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n            continueA = aAncestor !== null;\n            if (!aAncestorIsCommon && continueA) {\n              aAncestor = nodeMap.current[aAncestor].parentId;\n            }\n          }\n\n          if (continueB && !aAncestorIsCommon) {\n            bFamily.push(bAncestor);\n            bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n            continueB = bAncestor !== null;\n            if (!bAncestorIsCommon && continueB) {\n              bAncestor = nodeMap.current[bAncestor].parentId;\n            }\n          }\n        }\n\n        const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;\n        const ancestorFamily = getChildrenIds(commonAncestor);\n\n        const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];\n        const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];\n\n        return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide)\n          ? [nodeAId, nodeBId]\n          : [nodeBId, nodeAId];\n      },\n      []\n    );\n\n    const getNodesInRange = useCallback(\n      (nodeA, nodeB) => {\n        if (nodeA && nodeB) {\n          const [first, last] = findOrderInTremauxTree(nodeA, nodeB);\n          const nodes = [first];\n\n          let current = first;\n\n          while (current !== last) {\n            current = getNextNode(current);\n            nodes.push(current);\n          }\n\n          return nodes;\n        }\n        return [];\n      },\n      [findOrderInTremauxTree, getNextNode]\n    );\n\n    /*\n     * Focus Helpers\n     */\n    const focus = (event, id) => {\n      if (id) {\n        setFocusedNodeId(id);\n\n        if (nodeMap.current[id]?.onFocus) {\n          nodeMap.current[id].onFocus(event);\n        }\n      }\n    };\n\n    const focusNextNode = (event, id) => focus(event, getNextNode(id));\n    const focusPreviousNode = (event, id) => focus(event, getPreviousNode(id));\n    const focusFirstNode = (event) => focus(event, getFirstNode());\n    const focusLastNode = (event) => focus(event, getLastNode());\n\n    const focusByFirstCharacter = (event, id, char) => {\n      let start;\n      let index;\n      const lowercaseChar = char.toLowerCase();\n\n      const firstCharIds: string[] = [];\n      const firstChars: string[] = [];\n      // This really only works since the ids are strings\n      Object.keys(firstCharMap.current).forEach((nodeId) => {\n        const firstChar = firstCharMap.current[nodeId];\n        const map = nodeMap.current[nodeId];\n        const visible = map.parentId ? isExpanded(map.parentId) : true;\n        const shouldBeSkipped = disabledItemsFocusable\n          ? false\n          : isDisabled(nodeId);\n\n        if (visible && !shouldBeSkipped) {\n          firstCharIds.push(nodeId);\n          firstChars.push(firstChar);\n        }\n      });\n\n      // Get start index for search based on position of currentItem\n      start = firstCharIds.indexOf(id) + 1;\n      if (start >= firstCharIds.length) {\n        start = 0;\n      }\n\n      // Check remaining slots in the menu\n      index = findNextFirstChar(firstChars, start, lowercaseChar);\n\n      // If not found in remaining slots, check from beginning\n      if (index === -1) {\n        index = findNextFirstChar(firstChars, 0, lowercaseChar);\n      }\n\n      // If match was found...\n      if (index > -1) {\n        focus(event, firstCharIds[index]);\n      }\n    };\n\n    /*\n     * Expansion Helpers\n     */\n    const toggleExpansion = useCallback(\n      (event, value = focusedNodeId) => {\n        let newExpanded;\n\n        if (expanded.indexOf(value) !== -1) {\n          newExpanded = expanded.filter((id) => id !== value);\n        } else {\n          newExpanded = [value].concat(expanded);\n        }\n\n        if (onToggle) {\n          onToggle(event, newExpanded);\n        }\n\n        setExpandedState(newExpanded);\n      },\n      [expanded, focusedNodeId, onToggle, setExpandedState]\n    );\n\n    const expandAllSiblings = (event, id) => {\n      const map = nodeMap.current[id];\n      const siblings = getChildrenIds(map.parentId);\n\n      const diff = siblings.filter(\n        (child) => isExpandable(child) && !isExpanded(child)\n      );\n\n      const newExpanded = expanded.concat(diff);\n\n      if (diff.length > 0) {\n        setExpandedState(newExpanded);\n\n        if (onToggle) {\n          onToggle(event, newExpanded);\n        }\n      }\n    };\n\n    /*\n     * Selection Helpers\n     */\n    const lastSelectedNode = useRef<HTMLDivElement | null>(null);\n    const lastSelectionWasRange = useRef(false);\n    const currentRangeSelection = useRef<HTMLDivElement[]>([]);\n\n    const isDivElement = (element): element is HTMLDivElement => {\n      return (element as HTMLDivElement).nodeType === 1;\n    };\n\n    const handleRangeArrowSelect = useCallback(\n      (event, nodes: { start?; next?; current? }) => {\n        let base = selected.slice();\n        const { start, next, current } = nodes;\n\n        if (!next || !current) {\n          return;\n        }\n\n        if (\n          isDivElement(current) &&\n          currentRangeSelection.current.indexOf(current) === -1\n        ) {\n          currentRangeSelection.current = [];\n        }\n\n        if (lastSelectionWasRange.current) {\n          if (\n            isDivElement(next) &&\n            currentRangeSelection.current.indexOf(next) !== -1\n          ) {\n            base = base.filter((id) => id === start || id !== current);\n            currentRangeSelection.current =\n              currentRangeSelection.current.filter(\n                (id) => id === start || id !== current\n              );\n          } else {\n            base.push(next);\n            currentRangeSelection.current.push(next);\n          }\n        } else {\n          base.push(next);\n          currentRangeSelection.current.push(current, next);\n        }\n\n        if (onChange) {\n          onChange(\n            event,\n            base,\n            base.map((id) => nodeMap.current[id]?.payload)\n          );\n        }\n\n        setSelectedState(base);\n      },\n      [onChange, selected, setSelectedState]\n    );\n\n    const handleRangeSelect = useCallback(\n      (event, nodes: { start?; end?; current? }) => {\n        let base = selected.slice();\n        const { start, end } = nodes;\n        // If last selection was a range selection ignore nodes that were selected.\n        if (lastSelectionWasRange.current) {\n          base = base.filter(\n            (id) => currentRangeSelection.current.indexOf(id) === -1\n          );\n        }\n\n        let range = getNodesInRange(start, end);\n        range = range.filter((node) => !isDisabled(node));\n        currentRangeSelection.current = range;\n        let newSelected = base.concat(range);\n        newSelected = newSelected.filter(\n          (id, i) => newSelected.indexOf(id) === i\n        );\n\n        if (onChange) {\n          onChange(\n            event,\n            newSelected,\n            newSelected.map((id) => nodeMap.current[id]?.payload)\n          );\n        }\n\n        setSelectedState(newSelected);\n      },\n      [getNodesInRange, isDisabled, onChange, selected, setSelectedState]\n    );\n\n    const handleMultipleSelect = useCallback(\n      (event, value) => {\n        let newSelected;\n        if (selected.indexOf(value) !== -1) {\n          newSelected = selected.filter((id) => id !== value);\n        } else {\n          newSelected = [value].concat(selected);\n        }\n\n        if (onChange) {\n          onChange(\n            event,\n            newSelected,\n            newSelected.map((id) => nodeMap.current[id]?.payload)\n          );\n        }\n\n        setSelectedState(newSelected);\n      },\n      [onChange, selected, setSelectedState]\n    );\n\n    const handleSingleSelect = useCallback(\n      (event, value) => {\n        const newSelected = multiSelect ? [value] : value;\n        if (onChange) {\n          const nodeValue = nodeMap.current[newSelected]?.payload;\n          onChange(event, newSelected, multiSelect ? [nodeValue] : nodeValue);\n        }\n\n        setSelectedState(newSelected);\n      },\n      [multiSelect, onChange, setSelectedState]\n    );\n\n    const selectNode = useCallback(\n      (event, id, multiple = false) => {\n        if (id && isSelectable(id)) {\n          if (multiple) {\n            handleMultipleSelect(event, id);\n          } else {\n            handleSingleSelect(event, id);\n          }\n          lastSelectedNode.current = id;\n          lastSelectionWasRange.current = false;\n          currentRangeSelection.current = [];\n\n          return true;\n        }\n        return false;\n      },\n      [handleMultipleSelect, handleSingleSelect, isSelectable]\n    );\n\n    const selectRange = useCallback(\n      (\n        event,\n        nodes: { start?; end?; current?: HTMLDivElement | null },\n        stacked = false\n      ) => {\n        const { start = lastSelectedNode.current, end, current } = nodes;\n        if (stacked) {\n          handleRangeArrowSelect(event, { start, next: end, current });\n        } else if (start != null && end != null) {\n          handleRangeSelect(event, { start, end });\n        }\n        lastSelectionWasRange.current = true;\n      },\n      [handleRangeArrowSelect, handleRangeSelect]\n    );\n\n    const rangeSelectToFirst = (event, id) => {\n      if (!lastSelectedNode.current) {\n        lastSelectedNode.current = id;\n      }\n\n      const start = lastSelectionWasRange.current\n        ? lastSelectedNode.current\n        : id;\n\n      selectRange(event, {\n        start,\n        end: getFirstNode(),\n      });\n    };\n\n    const rangeSelectToLast = (event: any, id) => {\n      if (!lastSelectedNode.current) {\n        lastSelectedNode.current = id;\n      }\n\n      const start = lastSelectionWasRange.current\n        ? lastSelectedNode.current\n        : id;\n\n      selectRange(event, {\n        start,\n        end: getLastNode(),\n      });\n    };\n\n    const selectNextNode = (event, id) => {\n      if (!isDisabled(getNextNode(id))) {\n        selectRange(\n          event,\n          {\n            end: getNextNode(id),\n            current: id,\n          },\n          true\n        );\n      }\n    };\n\n    const selectPreviousNode = (event, id) => {\n      if (!isDisabled(getPreviousNode(id))) {\n        selectRange(\n          event,\n          {\n            end: getPreviousNode(id),\n            current: id,\n          },\n          true\n        );\n      }\n    };\n\n    const selectAllNodes = (event) => {\n      selectRange(event, { start: getFirstNode(), end: getLastNode() });\n    };\n\n    /*\n     * Mapping Helpers\n     */\n    const registerNode = useCallback((node) => {\n      const {\n        id,\n        index,\n        parentId,\n        expandable,\n        idAttribute,\n        disabled,\n        selectable: nodeSelectable,\n        onFocus: nodeOnFocus,\n        payload,\n      } = node;\n\n      nodeMap.current[id] = {\n        id,\n        index,\n        parentId,\n        expandable,\n        idAttribute,\n        disabled,\n        selectable: nodeSelectable,\n        onFocus: nodeOnFocus,\n        payload,\n      };\n    }, []);\n\n    const unregisterNode = useCallback((id) => {\n      const newMap = { ...nodeMap.current };\n      delete newMap[id];\n      nodeMap.current = newMap;\n\n      setFocusedNodeId((oldFocusedNodeId) => {\n        if (\n          oldFocusedNodeId === id &&\n          treeRef.current &&\n          treeRef.current ===\n            (treeRef.current.ownerDocument || document).activeElement\n        ) {\n          return getChildrenIds(null)[0];\n        }\n        return oldFocusedNodeId;\n      });\n    }, []);\n\n    const mapFirstChar = useCallback((id, firstChar) => {\n      firstCharMap.current[id] = firstChar;\n    }, []);\n\n    const unMapFirstChar = useCallback((id) => {\n      const newMap = { ...firstCharMap.current };\n      delete newMap[id];\n      firstCharMap.current = newMap;\n    }, []);\n\n    /**\n     * Event handlers and Navigation\n     */\n    const handleNextArrow = (event) => {\n      if (isExpandable(focusedNodeId)) {\n        if (isExpanded(focusedNodeId)) {\n          focusNextNode(event, focusedNodeId);\n        } else if (!isDisabled(focusedNodeId)) {\n          toggleExpansion(event);\n        }\n      }\n      return true;\n    };\n\n    const handlePreviousArrow = (event) => {\n      if (isExpanded(focusedNodeId) && !isDisabled(focusedNodeId)) {\n        toggleExpansion(event, focusedNodeId);\n        return true;\n      }\n\n      const parent = getParent(focusedNodeId);\n      if (parent) {\n        focus(event, parent);\n        return true;\n      }\n      return false;\n    };\n\n    const handleKeyDown = (event) => {\n      let flag = false;\n      const { key } = event;\n\n      // If the tree is empty there will be no focused node\n      if (\n        event.altKey ||\n        event.currentTarget !== event.target ||\n        !focusedNodeId\n      ) {\n        return;\n      }\n\n      const ctrlPressed = event.ctrlKey || event.metaKey;\n      switch (key) {\n        case \" \":\n          if (isSelectable(focusedNodeId) && !isDisabled(focusedNodeId)) {\n            if (multiSelect && event.shiftKey) {\n              selectRange(event, { end: focusedNodeId });\n              flag = true;\n            } else if (multiSelect) {\n              flag = selectNode(event, focusedNodeId, true);\n            } else {\n              flag = selectNode(event, focusedNodeId);\n            }\n          }\n          event.stopPropagation();\n          break;\n        case \"Enter\":\n          if (!isDisabled(focusedNodeId)) {\n            if (isExpandable(focusedNodeId)) {\n              toggleExpansion(event);\n              flag = true;\n            } else if (isSelectable(focusedNodeId)) {\n              if (multiSelect && event.shiftKey) {\n                selectRange(event, { end: focusedNodeId });\n                flag = true;\n              } else if (multiSelect) {\n                flag = selectNode(event, focusedNodeId, true);\n              } else {\n                flag = selectNode(event, focusedNodeId);\n              }\n            }\n          }\n          event.stopPropagation();\n          break;\n        case \"ArrowDown\":\n          if (multiSelect && event.shiftKey) {\n            selectNextNode(event, focusedNodeId);\n          }\n          focusNextNode(event, focusedNodeId);\n          flag = true;\n          break;\n        case \"ArrowUp\":\n          if (multiSelect && event.shiftKey) {\n            selectPreviousNode(event, focusedNodeId);\n          }\n          focusPreviousNode(event, focusedNodeId);\n          flag = true;\n          break;\n        case \"ArrowRight\":\n          flag = handleNextArrow(event);\n          break;\n        case \"ArrowLeft\":\n          flag = handlePreviousArrow(event);\n          break;\n        case \"Home\":\n          if (\n            multiSelect &&\n            ctrlPressed &&\n            event.shiftKey &&\n            !isDisabled(focusedNodeId)\n          ) {\n            rangeSelectToFirst(event, focusedNodeId);\n          }\n          focusFirstNode(event);\n          flag = true;\n          break;\n        case \"End\":\n          if (\n            multiSelect &&\n            ctrlPressed &&\n            event.shiftKey &&\n            !isDisabled(focusedNodeId)\n          ) {\n            rangeSelectToLast(event, focusedNodeId);\n          }\n          focusLastNode(event);\n          flag = true;\n          break;\n        default:\n          if (key === \"*\") {\n            expandAllSiblings(event, focusedNodeId);\n            flag = true;\n          } else if (multiSelect && ctrlPressed && key.toLowerCase() === \"a\") {\n            selectAllNodes(event);\n            flag = true;\n          } else if (\n            !ctrlPressed &&\n            !event.shiftKey &&\n            isPrintableCharacter(key)\n          ) {\n            focusByFirstCharacter(event, focusedNodeId, key);\n            flag = true;\n          }\n      }\n\n      if (flag) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n    };\n\n    const handleFocus = (event) => {\n      // if the event bubbled (which is React specific) we don't want to steal focus\n      if (event.target === event.currentTarget) {\n        const firstSelected = Array.isArray(selected) ? selected[0] : selected;\n        focus(event, firstSelected || getNavigableChildrenIds(null)[0]);\n      }\n\n      if (onFocus) {\n        onFocus(event);\n      }\n    };\n\n    const handleBlur = (event) => {\n      setFocusedNodeId(null);\n\n      if (onBlur) {\n        onBlur(event);\n      }\n    };\n\n    const activeDescendant =\n      focusedNodeId && nodeMap.current[focusedNodeId]\n        ? nodeMap.current[focusedNodeId].idAttribute\n        : null;\n\n    const treeControlContext = useMemo(\n      () => ({\n        treeId,\n        mode,\n        collapsible,\n        toggleExpansion,\n        multiSelect,\n        selectNode: selectable ? selectNode : noopSelection,\n        selectRange: selectable ? selectRange : noopSelection,\n        disabledItemsFocusable,\n        registerNode,\n        unregisterNode,\n        mapFirstChar,\n        unMapFirstChar,\n        focus,\n      }),\n      [\n        registerNode,\n        unregisterNode,\n        mapFirstChar,\n        unMapFirstChar,\n        toggleExpansion,\n        selectable,\n        selectNode,\n        selectRange,\n        mode,\n        collapsible,\n        multiSelect,\n        disabledItemsFocusable,\n        treeId,\n      ]\n    );\n\n    const treeStateContext = useMemo(\n      () => ({\n        isExpanded,\n        isSelected,\n        isFocused,\n        isDisabled,\n        isChildSelected,\n      }),\n      [isDisabled, isExpanded, isFocused, isSelected, isChildSelected]\n    );\n\n    return (\n      <TreeViewControlContext.Provider value={treeControlContext}>\n        <TreeViewStateContext.Provider value={treeStateContext}>\n          <DescendantProvider>\n            <ul\n              ref={handleRef}\n              id={idProp}\n              className={cx(classes.root, className)}\n              {...(treeviewMode && {\n                id: treeId,\n                role: \"tree\",\n                \"aria-multiselectable\": multiSelect,\n                \"aria-activedescendant\": activeDescendant,\n                tabIndex: 0,\n                onFocus: handleFocus,\n                onBlur: handleBlur,\n                onKeyDown: handleKeyDown,\n              })}\n              {...others}\n            >\n              {children}\n            </ul>\n          </DescendantProvider>\n        </TreeViewStateContext.Provider>\n      </TreeViewControlContext.Provider>\n    );\n  }\n);\n"],"names":[],"mappings":"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"}