"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const utils = require("@mui/material/utils");
const uikitReactIcons = require("@hitachivantara/uikit-react-icons");
const useDefaultProps = require("../hooks/useDefaultProps.cjs");
const useControlled = require("../hooks/useControlled.cjs");
const useUniqueId = require("../hooks/useUniqueId.cjs");
const useLabels = require("../hooks/useLabels.cjs");
const setId = require("../utils/setId.cjs");
const useSavedState = require("../utils/useSavedState.cjs");
const utils$2 = require("../Calendar/utils.cjs");
const utils$1 = require("./utils.cjs");
const useVisibleDate = require("./useVisibleDate.cjs");
const DatePicker_styles = require("./DatePicker.styles.cjs");
const Calendar = require("../Calendar/Calendar.cjs");
const Button = require("../Button/Button.cjs");
const validationStates = require("../Forms/FormElement/validationStates.cjs");
const FormElement = require("../Forms/FormElement/FormElement.cjs");
const Label = require("../Forms/Label/Label.cjs");
const InfoMessage = require("../Forms/InfoMessage/InfoMessage.cjs");
const BaseDropdown = require("../BaseDropdown/BaseDropdown.cjs");
const WarningText = require("../Forms/WarningText/WarningText.cjs");
const ActionBar = require("../ActionBar/ActionBar.cjs");
const Typography = require("../Typography/Typography.cjs");
const DEFAULT_LABELS = {
  /** Apply button label. */
  applyLabel: "Apply",
  /** Cancel button label. */
  cancelLabel: "Cancel",
  /** Clear button label. */
  clearLabel: "Clear",
  /** Invalid Date label. */
  invalidDateLabel: "Invalid date"
};
const HvDatePicker = React.forwardRef(
  (props, ref) => {
    const {
      classes: classesProp,
      className,
      id,
      name,
      required = false,
      disabled = false,
      readOnly,
      label,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      description,
      "aria-describedby": ariaDescribedBy,
      onChange,
      onCancel,
      onClear,
      status,
      statusMessage,
      "aria-errormessage": ariaErrorMessage,
      placeholder,
      labels: labelsProp,
      value,
      startValue,
      endValue,
      expanded,
      defaultExpanded,
      onToggle,
      rangeMode = false,
      startAdornment,
      horizontalPlacement = "right",
      locale: localeProp,
      showActions = false,
      showClear = false,
      disablePortal = true,
      escapeWithReference = true,
      dropdownProps = {},
      calendarProps,
      ...others
    } = useDefaultProps.useDefaultProps("HvDatePicker", props);
    const { classes, cx } = DatePicker_styles.useClasses(classesProp);
    const labels = useLabels.useLabels(DEFAULT_LABELS, labelsProp);
    const elementId = useUniqueId.useUniqueId(id, "hvdatepicker");
    const [validationState, setValidationState] = useControlled.useControlled(
      status,
      "standBy"
    );
    const [validationMessage] = useControlled.useControlled(statusMessage, "Required");
    const locale = localeProp || "en-US";
    const [calendarOpen, setCalendarOpen] = useControlled.useControlled(
      expanded,
      Boolean(defaultExpanded)
    );
    const [startDate, setStartDate, rollbackStartDate] = useSavedState.useSavedState(
      rangeMode ? startValue : value
    );
    const [endDate, setEndDate, rollbackEndDate] = useSavedState.useSavedState(endValue);
    const [visibleDate, dispatchAction] = useVisibleDate.default(startDate, endDate);
    const focusTarget = React.useRef(null);
    const { ref: refProp, ...otherDropdownProps } = dropdownProps;
    const dropdownForkedRef = utils.useForkRef(ref, refProp);
    React.useEffect(() => {
      setStartDate(rangeMode ? startValue : value, true);
      setEndDate(endValue, true);
    }, [value, startValue, endValue, rangeMode, setStartDate, setEndDate]);
    const endDateIsSet = React.useRef(false);
    endDateIsSet.current = endDate != null;
    React.useEffect(() => {
      if (startDate != null) {
        dispatchAction({
          type: "month_year",
          target: endDateIsSet.current ? "left" : "best",
          year: startDate.getFullYear(),
          month: startDate.getMonth() + 1
        });
      }
    }, [dispatchAction, startDate]);
    React.useEffect(() => {
      if (endDate != null) {
        dispatchAction({
          type: "month_year",
          target: "right",
          year: endDate.getFullYear(),
          month: endDate.getMonth() + 1
        });
      }
    }, [dispatchAction, endDate]);
    const handleApply = () => {
      setStartDate(startDate, true);
      setEndDate(endDate ?? startDate, true);
      onChange?.(startDate, endDate);
      setValidationState(() => {
        if (required && (!utils$2.isDate(startDate) || rangeMode && !utils$2.isDate(endDate))) {
          return "invalid";
        }
        return "valid";
      });
      setCalendarOpen(false);
    };
    const handleCancel = () => {
      rollbackStartDate();
      rollbackEndDate();
      onCancel?.();
      setCalendarOpen(false);
    };
    const handleClear = () => {
      setStartDate(void 0, false);
      setEndDate(void 0, false);
      onClear?.();
    };
    const handleCalendarClose = () => {
      if (rangeMode || showActions) {
        handleCancel();
      }
    };
    const handleToggle = (evt, open) => {
      if (evt === null)
        return;
      onToggle?.(evt, open);
      setCalendarOpen(open);
      if (!open)
        handleCalendarClose();
    };
    const focusOnContainer = () => {
      focusTarget.current?.focus();
    };
    const handleDateChange = (event, newDate) => {
      if (!utils$2.isDate(newDate))
        return;
      const autoSave = !showActions && !rangeMode;
      if (rangeMode) {
        if (!startDate || startDate && endDate || newDate < startDate) {
          setStartDate(newDate);
          setEndDate(void 0);
        } else {
          setEndDate(newDate);
        }
      } else {
        setStartDate(newDate, autoSave);
      }
      if (autoSave) {
        onChange?.(newDate);
        setValidationState(() => {
          if (required && !utils$2.isDate(newDate)) {
            return "invalid";
          }
          return "valid";
        });
        setCalendarOpen(false);
      }
    };
    const handleInputDateChange = (event, newDate, position) => {
      if (!utils$2.isDate(newDate))
        return;
      if (!rangeMode) {
        handleDateChange(event, newDate);
        return;
      }
      if (position === "left") {
        if (endDate)
          setStartDate(newDate > endDate ? endDate : newDate);
      } else if (position === "right") {
        if (!startDate) {
          if (endDate)
            setStartDate(newDate > endDate ? endDate : newDate);
          return;
        }
        setEndDate(newDate < startDate ? startDate : newDate);
      }
    };
    const renderActions = () => /* @__PURE__ */ jsxRuntime.jsxs(ActionBar.HvActionBar, { className: cx({ [classes.actionContainer]: showClear }), children: [
      showClear && /* @__PURE__ */ jsxRuntime.jsx("div", { className: classes.leftContainer, children: /* @__PURE__ */ jsxRuntime.jsx(
        Button.HvButton,
        {
          id: setId.setId(id, "action", "clear"),
          className: classes.action,
          variant: "primaryGhost",
          onClick: handleClear,
          children: labels?.clearLabel
        }
      ) }),
      /* @__PURE__ */ jsxRuntime.jsxs("div", { className: classes.rightContainer, children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          Button.HvButton,
          {
            id: setId.setId(id, "action", "apply"),
            className: classes.action,
            variant: "primaryGhost",
            onClick: handleApply,
            children: labels?.applyLabel
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(
          Button.HvButton,
          {
            id: setId.setId(id, "action", "cancel"),
            className: classes.action,
            variant: "primaryGhost",
            onClick: handleCancel,
            children: labels?.cancelLabel
          }
        )
      ] })
    ] });
    const renderInput = (dateString) => {
      return /* @__PURE__ */ jsxRuntime.jsx(
        Typography.HvTypography,
        {
          className: cx(classes.inputText, { [classes.dateText]: dateString }),
          variant: "label",
          children: dateString || placeholder || ""
        }
      );
    };
    const dateValue = rangeMode ? { startDate, endDate } : startDate;
    const hasLabel = label != null;
    const hasDescription = description != null;
    const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
    const isStateInvalid = validationStates.isInvalid(validationState);
    let errorMessageId;
    if (isStateInvalid) {
      errorMessageId = canShowError ? setId.setId(elementId, "error") : ariaErrorMessage;
    }
    return /* @__PURE__ */ jsxRuntime.jsxs(
      FormElement.HvFormElement,
      {
        id,
        name,
        value: dateValue,
        status: validationState,
        disabled,
        required,
        className: cx(classes.root, className),
        readOnly,
        ...others,
        children: [
          (hasLabel || hasDescription) && /* @__PURE__ */ jsxRuntime.jsxs("div", { className: classes.labelContainer, children: [
            hasLabel && /* @__PURE__ */ jsxRuntime.jsx(
              Label.HvLabel,
              {
                id: setId.setId(elementId, "label"),
                label,
                className: classes.label
              }
            ),
            hasDescription && /* @__PURE__ */ jsxRuntime.jsx(
              InfoMessage.HvInfoMessage,
              {
                id: setId.setId(elementId, "description"),
                className: classes.description,
                children: description
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntime.jsxs(
            BaseDropdown.HvBaseDropdown,
            {
              ref: dropdownForkedRef,
              role: "combobox",
              classes: {
                root: classes.dropdown,
                panel: classes.panel,
                header: cx({ [classes.dropdownHeaderInvalid]: isStateInvalid }),
                headerOpen: classes.dropdownHeaderOpen
              },
              readOnly,
              disabled,
              disablePortal,
              variableWidth: true,
              placement: horizontalPlacement,
              expanded: calendarOpen,
              onToggle: handleToggle,
              onClickOutside: handleCalendarClose,
              onContainerCreation: focusOnContainer,
              placeholder: renderInput(utils$1.getDateLabel(dateValue, rangeMode, locale)),
              adornment: /* @__PURE__ */ jsxRuntime.jsx(
                uikitReactIcons.Calendar,
                {
                  className: classes.icon,
                  color: disabled ? "secondary_80" : void 0
                }
              ),
              popperProps: {
                modifiers: [
                  { name: "preventOverflow", enabled: escapeWithReference }
                ]
              },
              "aria-haspopup": "dialog",
              "aria-label": ariaLabel,
              "aria-labelledby": [label && setId.setId(elementId, "label"), ariaLabelledBy].join(" ").trim() || void 0,
              "aria-invalid": isStateInvalid ? true : void 0,
              "aria-errormessage": errorMessageId,
              "aria-describedby": [description && setId.setId(elementId, "description"), ariaDescribedBy].join(" ").trim() || void 0,
              ...otherDropdownProps,
              children: [
                /* @__PURE__ */ jsxRuntime.jsx("div", { ref: focusTarget, tabIndex: -1 }),
                /* @__PURE__ */ jsxRuntime.jsx(
                  Calendar.HvCalendar,
                  {
                    id: setId.setId(id, "calendar"),
                    startAdornment,
                    onChange: handleDateChange,
                    onInputChange: handleInputDateChange,
                    onVisibleDateChange: (_event, type, month, target) => {
                      dispatchAction({ type, target, month });
                    },
                    locale,
                    ...visibleDate,
                    ...calendarProps,
                    invalidDateLabel: labels?.invalidDateLabel
                  }
                ),
                (rangeMode || showActions) && renderActions()
              ]
            }
          ),
          canShowError && /* @__PURE__ */ jsxRuntime.jsx(
            WarningText.HvWarningText,
            {
              id: setId.setId(elementId, "error"),
              disableBorder: true,
              className: cx(classes.error),
              children: validationMessage
            }
          )
        ]
      }
    );
  }
);
exports.datePickerClasses = DatePicker_styles.staticClasses;
exports.HvDatePicker = HvDatePicker;
