import { jsxs, jsx } from "@emotion/react/jsx-runtime";
import { useRef, useState, useReducer, useMemo, useEffect } from "react";
import cloneDeep from "lodash/cloneDeep";
import isEqual from "lodash/isEqual";
import { useDefaultProps } from "../hooks/useDefaultProps.js";
import { HvQueryBuilderProvider, defaultOperators, defaultCombinators, defaultLabels } from "./Context.js";
import { emptyGroup, clearNodeIds } from "./utils/index.js";
import reducer from "./utils/reducer.js";
import { useClasses } from "./QueryBuilder.styles.js";
import { staticClasses } from "./QueryBuilder.styles.js";
import { RuleGroup } from "./RuleGroup/RuleGroup.js";
import { ConfirmationDialog } from "./ConfirmationDialog/ConfirmationDialog.js";
const HvQueryBuilder = (props) => {
  const {
    attributes,
    renderers,
    query,
    onChange,
    disableConfirmation = false,
    operators = defaultOperators,
    combinators = defaultCombinators,
    maxDepth = 1,
    labels = defaultLabels,
    readOnly = false,
    emptyRenderer = ["Empty", "IsNotEmpty"],
    classes: classesProp
  } = useDefaultProps("HvQueryBuilder", props);
  const { classes } = useClasses(classesProp);
  const currentAttributes = useRef(
    null
  );
  const initialQuery = useRef(query ?? emptyGroup());
  const [pendingAction, setPendingAction] = useState();
  const [prevState, setPrevState] = useState(initialQuery.current);
  const [initialState, setInitialState] = useState(true);
  const [state, dispatchAction] = useReducer(
    reducer,
    // Deep clone is needed to make sure that the "query" prop and "initialQuery" are not mutated
    cloneDeep(initialQuery.current)
  );
  const value = useMemo(
    () => ({
      dispatchAction,
      askAction: setPendingAction,
      attributes,
      operators,
      combinators,
      maxDepth,
      labels,
      initialTouched: initialState,
      readOnly,
      renderers,
      disableConfirmation,
      emptyRenderer
    }),
    [
      attributes,
      operators,
      combinators,
      maxDepth,
      labels,
      readOnly,
      initialState,
      renderers,
      disableConfirmation,
      emptyRenderer
    ]
  );
  useEffect(() => {
    if (currentAttributes.current == null) {
      currentAttributes.current = attributes;
    } else if (currentAttributes.current !== attributes) {
      currentAttributes.current = attributes;
      dispatchAction({ type: "reset-query" });
    }
  }, [attributes]);
  useEffect(() => {
    if (!isEqual(state, prevState)) {
      if (initialState) {
        setInitialState(false);
      }
      onChange?.(clearNodeIds(state));
      setPrevState(cloneDeep(state));
    }
  }, [initialState, onChange, prevState, state]);
  const handleConfirm = () => {
    if (pendingAction) {
      setPendingAction(void 0);
      pendingAction.actions.forEach((action) => dispatchAction(action));
    }
  };
  const handleCancel = () => {
    setPendingAction(void 0);
  };
  return /* @__PURE__ */ jsxs(HvQueryBuilderProvider, { value, children: [
    /* @__PURE__ */ jsx(
      RuleGroup,
      {
        level: 0,
        id: state.id,
        combinator: state.combinator,
        rules: state.rules,
        classes
      }
    ),
    /* @__PURE__ */ jsx(
      ConfirmationDialog,
      {
        isOpen: pendingAction != null,
        onConfirm: handleConfirm,
        onCancel: handleCancel,
        title: pendingAction?.dialog.dialogTitle || "",
        message: pendingAction?.dialog.dialogMessage || "",
        confirmButtonLabel: pendingAction?.dialog.dialogConfirm || "",
        cancelButtonLabel: pendingAction?.dialog.dialogCancel || "",
        closeButtonTooltip: pendingAction?.dialog.dialogCloseTooltip || ""
      }
    )
  ] });
};
export {
  HvQueryBuilder,
  staticClasses as queryBuilderClasses
};
