"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const Slider = require("rc-slider");
const Tooltip = require("rc-tooltip");
const setId = require("../utils/setId.cjs");
const useUniqueId = require("../hooks/useUniqueId.cjs");
const useControlled = require("../hooks/useControlled.cjs");
const validationStates = require("../Forms/FormElement/validationStates.cjs");
const useDefaultProps = require("../hooks/useDefaultProps.cjs");
const Slider_styles = require("./Slider.styles.cjs");
const utils = require("./utils.cjs");
const SliderInput = require("./SliderInput/SliderInput.cjs");
const FormElement = require("../Forms/FormElement/FormElement.cjs");
const Label = require("../Forms/Label/Label.cjs");
const WarningText = require("../Forms/WarningText/WarningText.cjs");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const Slider__default = /* @__PURE__ */ _interopDefault(Slider);
const Tooltip__default = /* @__PURE__ */ _interopDefault(Tooltip);
const HvSlider = React.forwardRef((props, ref) => {
  const {
    id,
    className,
    name,
    label,
    status,
    statusMessage,
    disabled,
    classes: classesProp,
    sliderProps,
    knobProps,
    inputProps,
    requiredMessage = "The value is required",
    noOverlap = true,
    hideInput = false,
    required = false,
    readOnly = false,
    markProperties = [],
    defaultValues = [void 0],
    values: valuesProp = [],
    knobProperties: knobPropertiesProp,
    "aria-errormessage": ariaErrorMessage,
    maxPointValue = 100,
    minPointValue = 0,
    divisionQuantity = 100,
    markStep = 20,
    markDigits = 0,
    formatMark,
    onChange,
    onBlur,
    onBeforeChange,
    onAfterChange,
    formatTooltip,
    ...others
  } = useDefaultProps.useDefaultProps("HvSlider", props);
  const { classes, cx } = Slider_styles.useClasses(classesProp);
  const hasLabel = label != null;
  const isDirty = React.useRef(false);
  const elementId = useUniqueId.useUniqueId(id, "hvSlider");
  const sliderInputId = setId.setId(elementId, "input");
  const stepValue = React.useMemo(
    () => utils.calculateStepValue(maxPointValue, minPointValue, divisionQuantity),
    [divisionQuantity, maxPointValue, minPointValue]
  );
  const inverseStepValue = 1 / stepValue;
  const marks = React.useMemo(
    () => utils.createMark(
      markProperties,
      markStep,
      divisionQuantity,
      minPointValue,
      stepValue,
      markDigits,
      !!disabled,
      formatMark
    ),
    [
      disabled,
      divisionQuantity,
      formatMark,
      markDigits,
      markProperties,
      markStep,
      minPointValue,
      stepValue
    ]
  );
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
  const isSingle = React.useMemo(
    () => utils.isSingleSlider(valuesProp, defaultValues),
    [defaultValues, valuesProp]
  );
  const value = React.useMemo(
    () => valuesProp?.length > 0 ? utils.knobsValuesToKnobsPositions(
      valuesProp,
      inverseStepValue,
      minPointValue
    ) : void 0,
    [inverseStepValue, minPointValue, valuesProp]
  );
  const defaultKnobsPositions = React.useMemo(
    () => utils.knobsValuesToKnobsPositions(
      defaultValues,
      inverseStepValue,
      minPointValue
    ),
    [defaultValues, inverseStepValue, minPointValue]
  );
  const [knobsPositions, setKnobsPositions] = useControlled.useControlled(
    value,
    defaultKnobsPositions
  );
  const { arrayStatus, arrayDefaultStatus } = React.useMemo(
    () => utils.convertStatusToArray(knobsPositions.length, status),
    [knobsPositions.length, status]
  );
  const [validationStatus, setValidationState] = useControlled.useControlled(
    arrayStatus,
    arrayDefaultStatus
  );
  const [validationMessage, setValidationMessage] = useControlled.useControlled(
    statusMessage,
    ""
  );
  const [isDraggingTrack, setIsDraggingTrack] = React.useState(false);
  const knobProperties = utils.generateDefaultKnobProperties(
    knobsPositions.length,
    disabled,
    knobPropertiesProp
  );
  const rangesCount = knobProperties.length - 1;
  const trackStyles = utils.createTrackStyles(knobProperties);
  const knobStyles = utils.createKnobStyles(knobProperties);
  const performValidation = React.useCallback(() => {
    let invalid = false;
    const newValidationState = knobsPositions.map((position) => {
      if (position == null || Number.isNaN(position)) {
        invalid = true;
        return validationStates.default.invalid;
      }
      return validationStates.default.valid;
    });
    setValidationState([...newValidationState]);
    if (invalid) {
      setValidationMessage(requiredMessage);
      return;
    }
    setValidationMessage("");
  }, [
    knobsPositions,
    requiredMessage,
    setValidationMessage,
    setValidationState
  ]);
  React.useEffect(() => {
    const stepVl = utils.calculateStepValue(
      maxPointValue,
      minPointValue,
      divisionQuantity
    );
    const inverseStepVl = 1 / stepVl;
    if (valuesProp?.length > 0) {
      setKnobsPositions(
        utils.knobsValuesToKnobsPositions(
          valuesProp.length > 0 ? valuesProp : defaultValues,
          inverseStepVl,
          minPointValue
        )
      );
    }
  }, [
    defaultValues,
    divisionQuantity,
    maxPointValue,
    minPointValue,
    setKnobsPositions,
    valuesProp
  ]);
  React.useEffect(() => {
    if (!isDirty.current) {
      return;
    }
    performValidation();
  }, [knobsPositions, requiredMessage, performValidation]);
  const onMouseDownHandler = (event) => {
    if (event.target.className.includes("track")) {
      setIsDraggingTrack(true);
    }
  };
  const onMouseUpHandler = () => {
    setIsDraggingTrack(false);
  };
  const generateKnobsPositionAndValues = (knobsCurrentPosition) => {
    const newKnobsPosition = knobsCurrentPosition.slice();
    const knobsValues = [];
    let duplicatedValue = null;
    const findDuplicated = newKnobsPosition.filter(
      (item, index) => newKnobsPosition.indexOf(item) !== index
    );
    if (noOverlap && findDuplicated.length > 0) {
      [duplicatedValue] = findDuplicated;
    }
    newKnobsPosition.forEach((position, index, array) => {
      const newArray = array;
      let newPosition = position;
      if (noOverlap && newPosition === duplicatedValue) {
        const previousValue = knobsPositions[index];
        if (previousValue !== newPosition) {
          newPosition += newPosition > previousValue ? -1 : 1;
          newArray[index] = newPosition;
        }
      }
      knobsValues[index] = utils.knobsPositionToScaledValue(
        newPosition,
        minPointValue,
        stepValue
      );
    }, void 0);
    return {
      knobsPosition: newKnobsPosition,
      knobsValues
    };
  };
  const onBlurHandler = (event) => {
    const knobs = generateKnobsPositionAndValues(knobsPositions);
    performValidation();
    onBlur?.(event, knobs.knobsValues, status);
  };
  const onChangeHandler = (knobsPosition) => {
    isDirty.current = true;
    const knobs = generateKnobsPositionAndValues(knobsPosition);
    knobProperties.forEach((knobProperty, index) => {
      if (knobProperty.fixed) {
        knobs.knobsPosition[index] = utils.scaledValueToKnobsPositionValue(
          defaultValues[index],
          minPointValue,
          inverseStepValue
        );
      }
    });
    if (disabled || readOnly)
      return;
    onChange?.(knobs.knobsValues);
    setKnobsPositions(knobs.knobsPosition);
  };
  const onInputChangeHandler = (inputValues, index) => {
    let newKnobPositions = utils.knobsValuesToKnobsPositions(
      inputValues,
      inverseStepValue,
      minPointValue
    );
    newKnobPositions = utils.ensureValuesConsistency(newKnobPositions, index);
    onChangeHandler(newKnobPositions);
  };
  const onBeforeChangeHandler = (knobsPosition) => {
    const knobs = generateKnobsPositionAndValues(knobsPosition);
    onBeforeChange?.(knobs.knobsValues);
  };
  const onAfterChangeHandler = (knobsPosition) => {
    const knobs = generateKnobsPositionAndValues(knobsPosition);
    onAfterChange?.(knobs.knobsValues);
  };
  const createKnob = (knobNode, params) => {
    const { value: knobValue, dragging, index } = params;
    const { style = {}, ...restProps } = knobNode.props;
    const scaledKnobValue = utils.knobsPositionToScaledValue(
      knobValue,
      minPointValue,
      stepValue
    ).toFixed(markDigits);
    if (dragging) {
      style.backgroundColor = knobProperties[index]?.dragColor;
    } else {
      style.backgroundColor = knobProperties[index]?.color;
    }
    const isEmpty = Number.isNaN(knobsPositions[index]) || knobsPositions[index] == null;
    const handleId = setId.setId(elementId, "knob");
    const indexedHandleId = setId.setId(handleId, index);
    return /* @__PURE__ */ jsxRuntime.jsx(
      "div",
      {
        className: cx({
          [classes.handleContainer]: !!(!disabled && !isEmpty),
          [classes.handleContainerDisabled]: !!(disabled && !isEmpty),
          [classes.handleHiddenContainer]: isEmpty || readOnly
        }),
        children: /* @__PURE__ */ jsxRuntime.jsx(
          Tooltip__default.default,
          {
            prefixCls: "rc-slider-tooltip",
            overlay: formatTooltip?.(scaledKnobValue) || scaledKnobValue,
            visible: dragging,
            placement: "top",
            overlayClassName: classes.sliderTooltip,
            getTooltipContainer: () => document.getElementById(indexedHandleId || ""),
            children: /* @__PURE__ */ jsxRuntime.jsx(
              "div",
              {
                id: indexedHandleId,
                style,
                className: classes.handle,
                ...restProps,
                "aria-label": `${label}-knob-${index}`,
                "aria-valuenow": utils.knobsPositionToScaledValue(
                  knobValue,
                  minPointValue,
                  stepValue
                ),
                "aria-valuemin": minPointValue,
                "aria-valuemax": maxPointValue,
                ...knobProps?.[index]
              }
            )
          }
        )
      },
      index
    );
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(
    FormElement.HvFormElement,
    {
      className: cx(
        classes.root,
        {
          [classes.trackStandBy]: !readOnly && !disabled && !isSingle && !isDraggingTrack,
          [classes.trackDragging]: !readOnly && !disabled && !isSingle && isDraggingTrack,
          [classes.rootDisabled]: !!disabled
        },
        className
      ),
      id,
      name,
      status: utils.statusArrayToFormStatus(validationStatus),
      disabled,
      required,
      readOnly,
      onMouseDown: onMouseDownHandler,
      onMouseUp: onMouseUpHandler,
      onBlur: onBlurHandler,
      ...others,
      children: [
        (hasLabel || !hideInput) && /* @__PURE__ */ jsxRuntime.jsxs(
          "div",
          {
            className: cx(classes.labelContainer, {
              [classes.labelIncluded]: hasLabel,
              [classes.onlyInput]: !hasLabel
            }),
            children: [
              hasLabel && /* @__PURE__ */ jsxRuntime.jsx(
                Label.HvLabel,
                {
                  id: setId.setId(elementId, "label"),
                  className: classes.label,
                  htmlFor: sliderInputId,
                  label
                }
              ),
              !hideInput && /* @__PURE__ */ jsxRuntime.jsx(
                SliderInput.HvSliderInput,
                {
                  id: sliderInputId,
                  label,
                  values: utils.knobsPositionsToKnobsValues(
                    knobsPositions,
                    stepValue,
                    minPointValue
                  ),
                  onChange: onInputChangeHandler,
                  status: validationStatus,
                  disabled,
                  readOnly,
                  markDigits,
                  inputProps
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx("div", { className: cx(classes.sliderBase, classes.sliderContainer), children: /* @__PURE__ */ jsxRuntime.jsx(
          Slider__default.default,
          {
            ref,
            range: !isSingle,
            handleRender: createKnob,
            className: cx(classes.sliderRoot, {
              [classes.rootRange]: !isSingle
            }),
            min: 0,
            max: divisionQuantity,
            step: 1,
            marks,
            dotStyle: disabled ? Slider_styles.sliderStyles.dotDisabled : Slider_styles.sliderStyles.dot,
            onChange: (singleValue) => onChangeHandler(Array().concat(singleValue)),
            onBeforeChange: (singleValue) => onBeforeChangeHandler(Array().concat(singleValue)),
            onAfterChange: (singleValue) => onAfterChangeHandler(Array().concat(singleValue)),
            value: knobsPositions.length === 0 ? void 0 : isSingle ? knobsPositions[0] : [...knobsPositions],
            allowCross: false,
            disabled,
            count: rangesCount,
            railStyle: Slider_styles.sliderStyles.rail,
            handleStyle: knobStyles.knobInner,
            trackStyle: trackStyles,
            draggableTrack: !readOnly && !isSingle,
            ...sliderProps
          }
        ) }),
        canShowError && /* @__PURE__ */ jsxRuntime.jsx(
          WarningText.HvWarningText,
          {
            id: setId.setId(elementId, "error"),
            className: classes.error,
            disableBorder: true,
            children: validationMessage
          }
        )
      ]
    }
  );
});
exports.sliderClasses = Slider_styles.staticClasses;
exports.HvSlider = HvSlider;
