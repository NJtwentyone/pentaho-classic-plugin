{"version":3,"file":"descendants.js","sources":["../../../../src/VerticalNavigation/TreeView/descendants.tsx"],"sourcesContent":["/**\n * Copied from https://github.com/mui-org/material-ui/blob/8763de1633d80295e7b83d8c21040dad333e6699/packages/material-ui-lab/src/TreeView/descendants.js\n * Credit: https://github.com/reach/reach-ui/blob/86a046f54d53b6420e392b3fa56dd991d9d4e458/packages/descendants/README.md\n *\n * - Added level (depth) property.\n * - Use local copy of useEnhancedEffect.\n */\n\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\nimport { useEnhancedEffect } from \"../../hooks/useEnhancedEffect\";\n\ntype Item = {\n  element?;\n  index?;\n  [key: string]: unknown;\n};\n\nfunction binaryFindElement(array, element) {\n  let start = 0;\n  let end = array.length - 1;\n\n  while (start <= end) {\n    const middle = Math.floor((start + end) / 2);\n\n    if (array[middle].element === element) {\n      return middle;\n    }\n\n    if (\n      array[middle].element.compareDocumentPosition(element) &&\n      Node.DOCUMENT_POSITION_PRECEDING\n    ) {\n      end = middle - 1;\n    } else {\n      start = middle + 1;\n    }\n  }\n\n  return start;\n}\n\nconst DescendantContext = createContext<DescendantContextValue>({\n  level: 0,\n  descendants: [],\n});\n\ninterface DescendantContextValue {\n  level?: number;\n  registerDescendant?;\n  unregisterDescendant?;\n  descendants: Item[];\n  parentId?;\n}\n\nfunction usePrevious(value) {\n  const ref = useRef(null);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\nconst noop = () => {};\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation.\n */\nexport function useDescendant(descendant) {\n  const [, forceUpdate] = useState<{} | null>();\n  const {\n    registerDescendant = noop,\n    unregisterDescendant = noop,\n    descendants = [],\n    parentId = null,\n    level = 0,\n  } = useContext(DescendantContext);\n\n  // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n  const index = descendants.findIndex(\n    (item) => item.element === descendant.element\n  );\n\n  const previousDescendants: Item[] | null = usePrevious(descendants);\n\n  // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n  const someDescendantsHaveChanged = descendants.some(\n    (newDescendant, position) => {\n      return (\n        previousDescendants && previousDescendants[position]\n        // previousDescendants[position].element !== newDescendant.element\n        // was not able to type check this, did not any difference\n      );\n    }\n  );\n\n  // Prevent any flashing\n  useEnhancedEffect(() => {\n    if (descendant.element) {\n      registerDescendant({\n        ...descendant,\n        index,\n      });\n      return () => {\n        unregisterDescendant(descendant.element);\n      };\n    }\n    forceUpdate({});\n\n    return undefined;\n  }, [\n    registerDescendant,\n    unregisterDescendant,\n    index,\n    someDescendantsHaveChanged,\n    descendant,\n  ]);\n\n  return { parentId, index, level };\n}\n\nexport const DescendantProvider = (props: DescendantProviderProps) => {\n  const { children, id, level } = props;\n\n  const [items, set] = useState<Item[]>([]);\n\n  const registerDescendant = useCallback(({ element, ...other }) => {\n    set((oldItems) => {\n      let newItems;\n      if (oldItems.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        return [\n          {\n            ...other,\n            element,\n            index: 0,\n          },\n        ];\n      }\n\n      const index = binaryFindElement(oldItems, element);\n\n      if (oldItems[index] && oldItems[index].element === element) {\n        // If the element is already registered, just use the same array\n        newItems = oldItems;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n\n        const newItem = {\n          ...other,\n          element,\n          index,\n        };\n\n        // If an index is not found we will push the element to the end.\n        newItems = oldItems.slice();\n        newItems.splice(index, 0, newItem);\n      }\n      newItems.forEach((item, position) => {\n        item.index = position;\n      });\n      return newItems;\n    });\n  }, []);\n\n  const unregisterDescendant = useCallback((element: Item) => {\n    set((oldItems) =>\n      oldItems.filter((item: Item) => element !== item.element)\n    );\n  }, []);\n\n  const value = useMemo(\n    () => ({\n      descendants: items,\n      registerDescendant,\n      unregisterDescendant,\n      parentId: id,\n      level,\n    }),\n    [items, registerDescendant, unregisterDescendant, id, level]\n  );\n\n  return (\n    <DescendantContext.Provider value={value}>\n      {children}\n    </DescendantContext.Provider>\n  );\n};\n\nexport type DescendantProviderProps = {\n  children?: React.ReactNode;\n  id?: string;\n  level?: number;\n};\n"],"names":[],"mappings":"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"}